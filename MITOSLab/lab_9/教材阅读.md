对应章节：

- Chapter 8: File system

- 8.1-8.3 在lab_8中总结，这里主要是后续知识点

## 知识点总结

- xv6磁盘布局：

    ![](https://pic2.zhimg.com/80/v2-4a07df7734367c3a8ea2f474ee80e125_720w.webp)
- xv6采用数据日志来解决崩溃一致性问题
    
    > 类似InnoDB的redo log + checkpoing

- 组提交Group Commit: 将多个FS系统调用的事务，合并成一个大的事务，然后一次性提交

    - 减少磁盘操作次数，可能可以组织成顺序写

- xv6一次只能处理一个事务，即在完成这次事务的提交之前，不能执行另一个新的系统调用

    而以Linux的ext3为例，可以在提交一个事务的同时，并发地执行另一个系统调用，写入新的事务。

- xv6利用日志进行崩溃恢复原理: 

    - 将每次FS系统调用修改的cache buffer复制一份到磁盘的对应的日志区域块中，并且记录日志区域块中有多少是需要写入磁盘的

    - 当文件系统重新启动时，检查这个记录，如果发现还有日志区域块的每写入磁盘，则进行写入操作

    > 个人理解：如果在将cache buffer复制过程中崩溃，则也无法恢复，但是在复制过程中崩溃，也代表这个事务没有做完，不应该影响文件系统

- xv6的磁盘块分配器在磁盘上维护一个位图，该位图的每一位都表示一个块是已分配还是空闲，1表示已分配，而0表示空闲

- 一个inode对应一个文件/目录，包含了大小，数据块的位置等基本信息

- 当一个文件的硬链接数nlink为0，iput并不会马上就删除并释放该文件，因为在内存中可能还存在其它指向该文件的inode指针，甚至有进程仍然在读写这个文件

    - 问题： 如果崩溃，则该inode仍然被标记为分配，但是却没有任何指针指向它，我们失去了这块磁盘空间

    - 解决：
        - 系统启动，扫描磁盘上的文件系统，检查是否有文件被标记分配但是nlink=0, 然后释放

        - 或者在磁盘的某个位置，记录nlink=0,当ref!=0的文件的inode号，这样系统启动时只需要释放这部分记录的文件即可
    
    > xv6没有采用以上两种方法，所以会浪费空间   


- 如果有多个进程同时打开同一个文件，它们的struct file实例是不同的，即它们会有不同的偏移量。另一方面，相同的struct file实例，可以多次出现在一个或多个进程的打开文件表中，例如使用open打开文件之后，又调用了dup或fork等系统调用时，就会出现这种情况。

- **每个xv6进程都有一个打开文件表ofile**



