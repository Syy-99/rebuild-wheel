对应章节：

- Chapter 6: Locking

- Section 3.5: "Code: Physical memory allocator

    > 这部分主要阅读代码实现

- Section 8.1 through 8.3: "Overview", "Buffer cache layer", and "Code: Buffer cache"

## 知识点总结

### Chapter 6: Locking

- 临界区：访问共享资源的**代码段**

    竞争条件：多个执行线程同时进入临界区并尝试更新共享数据结构的情况

- 锁的作用：

    1. 使用锁有助于避免更新的丢失: 进程A的更新被进程B的更新覆盖

    2. 使用锁使多步操作变为原子性的操作

    3. 用锁有助于维持一些规则或特性的不变性

- 有两种处理操作系统临界区问题的常用方法：
    
    1. 抢占式内核：允许在内核空间运行的进程被抢占

    2. 非抢占式内核：....

        - 非抢占式内核基本不会导致竞争条件，因为任一时刻只有一个进程在内核空间下运行

            > 如何理解?
            >
            > 和线程不同，操作系统中，多个进程共享的数据结构一定在内核中，所以非抢占式基本不会竞争

- 互斥锁类型：

    1. 自旋锁Spinging Lock: 无法获得锁时，一直循环等待(占用CPU)

        - Q: 处在自旋状态的线程，可能RR算法产生时间中断，调用其他线程 

        - 如果中断处理程序需要持有某一把自旋锁，那么每个CPU在持有这把自旋锁时，一定要保持中断关闭。

            xv6的解决方式更加保守一些：只要CPU试图获取任何自旋锁，那么该CPU总是会关闭中断

            >  如何理解？
            > 
            > 考虑这一个场景: 我们为变量a维护一个自旋锁ticklock, 中断处理程序B和线程A都 需要获得自旋锁来修改某个变量。
            >
            >假设线程A持有该锁时，突然发生中断跳到B中，此时B无法获得该锁，也就无法结束运行，也就**无法回到线程A**, 也就无法释放锁，最终变成死锁
            >
            > 其它CPU也无法选择该持有锁的内核线程调度运行，因为**线程A的状态还是Running, 因此不会被其他CPU的调度程序调用执行**

            > Q: 如果关中断，假如是一个单核机器，那是否意味着，一旦自旋，就无法切换线程了呢？
            >
            >  - 对于多核，每个CPU既有各自本地中断控制器，又有负责仲裁各核之间中断分配的全局中断控制
            >
            > - 假设发生自旋，即使关闭中断，其他CPU也可以调用之前使用自旋锁的线程运行，然后放弃该锁

        - 已经持有自旋锁的进程不应该主动放弃CPU,这可能会导致死锁

            > 因为一旦放弃CPU, CPU执行另一个正在自旋的进程，此时即无法获得锁，也无法获得中断（中断在之前被关闭）运行其他线程，导致死锁

    2. 睡眠锁Sleep Lock: 在acquire需要自旋等待时让出CPU；同时，在持有这种锁时，允许主动放弃CPU和开放中断。

        ```c
        // 在这里，有两个lock，flag和guard
        typedef struct lock_t{
            int flag;
            int guard;
            queue_t *q;
        } lock_t;

        void lock_init(lock_t *m){
            m->flag = 0;
            m->guard = 0;
            queue_init(m->q);
        }

        void lock(lock_t *m){
            while(TestAndSet(&m->guard, 1) == 1)
                ;  // 自旋地等待直到获取guard lock
            if(m->flag == 0){
                m->flag = 1;   // flag lock还没有被获取，因此成功获取
                m->guard = 0;  // 释放guard lock
            }else{
                queue_add(m->q, gettid());  // flag lock已经被获取，该线程将进入队列中睡眠
                m->guard = 0;  // 睡眠之前释放guard lock
                park();        // 睡眠
            }
        }

        void unlock(lock_t *m){
            while(TestAndSet(&m->guard, 1) == 1)
                ;  // 自旋地等待直到获取guard lock
            if(queue_empty(m->q))
                m->flag = 0;  //没有人要获取flag lock，直接释放它
            else
                unpark(queue_remove(m->q));  // 从队列里唤醒一个线程，把flag lock交给它
            m->guard = 0;  // 结束之前释放guard lock
        }
        ```
        > Q: 为什们需要两个锁呢?
        >
        > 实际上锁也是一个共享变量，因此也需要锁来保护
        > 而自旋锁因为它特殊的访问访问，通过test_and_set指令(硬件保证)，来确保不会有进程同时访问一个空闲的自旋锁
        - xv6的睡眠锁实现，允许中断开放，因此中断处理程序不能使用睡眠锁（同样会导致死锁）
    
- 锁也是共享资源，可能出现多个进程争夺锁

- 避免因多个锁的上锁顺序导致的死锁问题，只需要规定一个全局的上锁顺序即可


### 8.1 - 8.3

- xv6文件系统的层次结构有7层:

    ![](https://pic3.zhimg.com/80/v2-429c8f0eac2e0f2f9a472276a09a8de2_720w.webp)    

    - 最底层的磁盘层Disk Layer，与QEMU仿真的虚拟磁盘打交道，往磁盘上读或写一些块。
    
    - 缓冲区缓存层Buffer Cache Layer，负责**将磁盘块缓存在内存**中，并且在这一层**管理所有进程对缓存块的并发访问**，保证**一次只能有一个进程修改某一缓存块**。

    - 日志层Logging Layer，为高层提供更新磁盘的接口，高层的对几个磁盘块的更新，将被打包成事务放入日志层，日**志层随后确保这些更新是原子的，并且能提供Crash Recovery**。

    - inode层Inode Layer，为文件层提供接口，**每个文件都是独立的，且有一个唯一的inode号标识，inode里面还有指向文件数据块所在磁盘位置的信息**。

    - 目录层Directory Layer，目录被看成是一种特殊的文件，因此它的inode含义也和普通文件不同，它的数**据是一系列的目录条目，包含该目录下的文件名和文件的inode号**。

    - 路径名层Pathname Layer，提供符合文件系统层次结构的路径名，处理路径名递归查找。

    - 文件描述符层File Descriptor Layer，最后，**文件描述符是对底层所有资源（管道、设备、普通文件等）的抽象，用户对文件系统的视图是简单而统一的，这方便了用户程序的编程。**

- xv6的块大小是1KB, 常见块大小是4KB

- xv6文件系统的磁盘布局（默认布局）： 

    ![](https://pic2.zhimg.com/80/v2-4a07df7734367c3a8ea2f474ee80e125_720w.webp)

    - 主要有：引导块，超级块，日志块，innodes块(每一块都有多个inodes记录)，位图块(记录后面数据块的使用情况)，数据块



## 阅读扩展
