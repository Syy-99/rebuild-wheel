对应章节：

- Chapter 7: Scheduling


## 知识点总结

- xv6中，CPU切换进程发生的情况：

    1. sleep和wakeup机制：进程在等待某种资源可用或某种条件成立时，可以**主动**通过sleep放弃CPU, 等条件满足后通过wakeup唤醒该进程重新执行

    2. RR调度机制： 每个进程有一个时间片，时间片耗尽就发生**时钟中断**, 当前进程被挂起，新的进程被调度

- 当一个进程不再需要执行时，应该在它退出时释放它的内存和相关资源，但是它自己不能完成所有的工作，例如**它不能释放自己的内核栈**，内核栈在该进程退出时仍然在被使用。

- 每个CPU需要知道自己当前执行的进程是哪个，这样在内核中执行系统调用时，对于与该进程相关的内核状态的修改是正确的。

- 调度流程：保存旧进程的相关运行状态和寄存器（上下文Context），然后通过某种方式选择一个将要执行的进程，恢复这个进程上次的运行状态，然后继续执行它，

    - 每个CPU都有一个调度线程，在没有任何用户进程可运行时，这些CPU就运行各自的调度线程

    - **每个进程的执行线程都对应一个内核线程，xrv的进程调度实际上是针对内核线程的**

        > 这句话要好好理解，CPU的调度程序在内核中运行，实际上是对内核线程进行切换；
        > 用户程序的执行线程通过和内核线程绑定，当内核线程切换时，就相当于切换了用户线程

- 内核线程的上下文保存在进程的结构p->context中，而CPU的调度线程上下文则保存至cpu->context中。

    > 用户态的上下文保存在进程的p->trapframe中, 内核态上下文是用户态上下文的子集
    >
    > (可以查看这两个成员的结构发现)

    - 上下文切换的核心函数是`swtch(a0, a1)`（kernel/swtch.S）
    
    - context里面并没有包含pc寄存器，而是包含了返回地址寄存器ra和栈指针寄存器sp
    
        这意味着，当保存和恢复这两个寄存器时，swtch就会返回到不同的内核线程中（通过ra），即返回到该线程上次调用swtch的地方，CPU因此在不同的内核栈上（通过sp）执行不同的代码

        > - Q：是否意味着成功执行`swtch()`后，原本在它下面的代码不会顺序执行，而是跳到其他地方执行？ -> 好像是这样的
        >
        > - Q: 假设内核线程A切换到内核线程B,那B中的context是否实际保存的是内核A的上下文呢？-> 应该是，当时中间实际是由调度程序执行，所以是调度程序的上下文

- **xv6调度完整流程： 用户进程PA->usertrap->内核线程TA->yiled(TA)->sched(TA)->swtch(TA,S)->调度线程S->swithc(S, TB)->sched(TB)->yield(TB)->内核线程TB->usertrap->用户进程PB**

   - sched和scheduler表现为一对协同程序。一个内核线程的sched通过swtch切换到scheduler中，而scheduler又通过swtch切换回到另一个内核线程的sched中

    - p->lock保证了取消调度和调度这两个过程的原子执行：

        1. `yield()`中的锁：如果进程状态是RUNNABLE，确保其他调度器不能执行该进程

        2. `scheduler()`中的锁：如果进程状态是RUNNING，确保该完成该进程的contex切换，不会因为时钟中断进入swtch时，context相关寄存器还没有加载，从而使得交换的另一个进程的contex的寄存器值不正确
        
    
- 内核实现`sleep()`和`wakeup()`

    - sleep将调用进程的运行状态标记为SLEEPING，然后调用sched让出CPU，后续的调度过程前面已经讨论过；
    
    - wakeup则查找一个睡眠/等待在给定频道channel上的进程，然后将其状态设为RUNNABLE。
    
    - 这个channel可以很随意地设置，xv6则经常使用一些内核数据结构的地址来作为channel，以将所有与该数据结构相关的进程，都关联到同一个channel上。

 
    > 1. 唤醒丢失: 进程A正在睡眠，但是另一个CPU执行了对应的唤醒函数到wakeup, 因为A的睡眠没有加锁，因此wakup遍历整个进程表，会跳过A, 然后A进入睡眠态，则本来对它进行唤醒操作就丢失了
    >
    > 1. 只要了sleep时加了锁就可以防止唤醒丢失，为什们有时要用两个锁？
    >       - 通过参数传递过来的是一个条件锁，调用sleep的进程A可以持有条件锁，在调用sleep之后，该条件锁可以被释放了，那么之前等待A进程完成某些工作的进程B就可以运行了(参考pipewirte/piperead同时操作空管道时的情形)
    >
    >       - 调用sleep的进程在设置进程状态为SLEEPING之前，可能持有条件锁lk，或持有p->lock，或者两个都持有；而wakeup在它的循环中检查进程的状态时，总是同时持有lk和p->lock。因此，对于生产者进程（调用sleep）和消费者进程（调用wakeup）来说，要么在生产者检查条件之前，消费者使条件满足；要么在生产者睡眠之后，消费者发现该进程并唤醒它。因此，采用严格的上锁机制之后，唤醒丢失不会再发生
    > 2. `wakeup1()`只在`exit()`中被使用，用来直接唤醒对应使用了wait()的父进程

    > 还是有点疑惑：wakeup时，sleep的进程还持有自己的p->lock,如何唤醒呢？

- 为了让父进程的wait发现子进程已经终止，子进程exit的时候，将其运行状态设置为ZOMBIE，然后wait就会注意到这个终止的子进程，并将该子进程标记为UNUSED，复制子进程的退出状态，并且返回子进程PID给父进程。

    > 僵尸进程的由来

-wait在一段时间内同时持有两把锁，而xv6规定的顺序是，先对父进程上锁(放置唤醒丢失)，再对子进程上锁(检查子进程的状态)，以防止死锁发生。


### 阅读拓展

Q: trapframe中与context的区别是什么？

- 内核调度器无论是通过时钟中断进入（usertrap），还是线程自己主动放弃 CPU（sleep、exit），最终都会调用到 yield 进一步调用 swtch。 由于上下文切换永远都发生在函数调用的边界（swtch 调用的边界），恢复执行相当于是 swtch 的返回过程，会从堆栈中恢复 caller-saved 的寄存器， 所以用于保存上下文的 context 结构体只需保存 callee-saved 寄存器，以及 返回地址 ra、栈指针 sp 即可。恢复后执行到哪里是通过 ra 寄存器来决定的（swtch 末尾的 ret 转跳到 ra）

- 而 trapframe 则不同，一个中断可能在任何地方发生，不仅仅是函数调用边界，也有可能在函数执行中途，所以恢复的时候需要靠 pc 寄存器来定位。 并且由于切换位置不一定是函数调用边界，所以几乎所有的寄存器都要保存（无论 caller-saved 还是 callee-saved），才能保证正确的恢复执行。 这也是内核代码中 struct trapframe 中保存的寄存器比 struct context 多得多的原因。

- 另外一个，无论是程序主动 sleep，还是时钟中断，都是通过 trampoline 跳转到内核态 usertrap（保存 trapframe），然后再到达 swtch 保存上下文的。 恢复上下文都是恢复到 swtch 返回前（依然是内核态），然后返回跳转回 usertrap，再继续运行直到 usertrapret 跳转到 trampoline 读取 trapframe，并返回用户态。 也就是上下文恢复并不是直接恢复到用户态，而是恢复到内核态 swtch 刚执行完的状态。负责恢复用户态执行流的其实是 trampoline 以及 trapframe。

    
