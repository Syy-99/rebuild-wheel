对应章节：

- Chapter 4: Traps and System Calls

## 知识点总结

- trap表示导致用户空间和内核空间的切换动作(系统调用/异常/设备中断)

- 用户空间发生trap的流程：

    1. `uservec`: 位于trampoline.S的前半部分汇编代码，用于做一些陷入内核之前的准备工作，例如保存用户空间下的一系列寄存器，加载内核栈、内核页表等设置，然后跳转到usertrap.这一部分，我们称为trap vector。

        > 当一个ecall指令被调用，首先跳到uservec的函数, 这个函数具有两个特征
        > - 必须由汇编编写，因为它需要直接操作寄存器。从用户态进入到内核态，需要在进程内部保存所有用户态的寄存器，否则进入内核以后没办法再返回来。
        > - 这个函数必须位于一个内核的页表和用户的页表相同的虚拟地址，因为这个函数需要切换用户页表到内核页表，**切换完了以后要能继续工作**。
        
        > 为了使页表切换前后，在用户空间下和内核空间下uservec都能正常运行，uservec应该被映射到内核页表和用户页表中的相同虚拟地址

        > XV6将一个叫trampoline的页(物理页)映射到相同的虚拟地址TRAMPOLINE,其中包含了trampoline.S的指令
        
    2. `usertrap()`(kernel/trap.c): 位于内核中的一段C代码，判断引起trap的事件类型，并决定如何处理该trap(如跳转到系统调用函数、设备驱动程序等).我们一般也称其为trap handler。

    3. `usertrapret()`(kernel/trap.c): 位于内核中的另一段C代码，**trap被处理完之后**，就会跳转到usertrapret，保存内核栈、内核页表等内核相关信息，进行一些设置，然后跳转到userret

    4. `userret`: 位于trampoline的后半部分汇编代码，用于做一些返回用户空间的恢复工作，恢复之前保存的用户空间寄存器，最后返回用户空间，恢复用户进程指令流的执行。

    > 建议跟着book走一遍，了解上面几个函数的具体逻辑

- 与trap相关的控制寄存器：

    - `stev`: 内核将trap handler（在用户空间下的trap，是trampoline的uservec；在内核空间下的trap，是kernel/kernelvec.S中的kernelvec）写到stvec中。当trap发生时，RISC-V就会跳转到stvec中的地址，准备处理trap

        > 注意到：被写入的不是usertrap/kernneltrap, 可以任何trap vector是trac handler的准备部分

    - `sepc`: 当trap发生时，**RISC-V就将当前pc的值保存在sepc中**, 因为稍后RISC-V将使用stvec中的值来覆盖pc，从而开始执行trap handler

        > 用来保存返回地址

    - `scause`: RISV在这里存放一个数字，用来表示trap的原因

    - `sscratch`: 一个特别的寄存器，通常在用户空间发生trap，并进入到uservec之后，sscratch就装载着指向进程trapframe的指针（该进程的trapframe，在进程被创建，并从userret返回的时候，就已经被内核设置好并且放置到sscratch中）。RISC-V还提供了一条交换指令（csrrw），可以将任意寄存器与sscratch进行值的交换。sscratch的这些特性，便于在uservec中进行一些寄存器的保存、恢复工作。

    - `status`: 位于该寄存器中的SIE位，控制设备中断是否开启，如果SPIE被清0，RISC-V会推迟期间的设备中断，直到SIE被再次置位；SPP位指示一个trap是来自用户模式下还是监管者模式下的，因此也决定了sret要返回到哪个模式下。

    > - 以上这些控制寄存器不能在用户模式下访问，只有在内核中，在监管者模式下处理trap时，才能访问或设置这些寄存器
    > - 每个CPU都有各自的上述控制寄存器集合，因此在任一时刻，可能有多个CPU同时都在处理trap

- 当trap发生了之后，硬件做的事情实际上很少，CPU没有切换到内核页表，没有切换到内核栈，也没有保存任何的寄存器（除了PC）。因此，内核中的代码必须完成以上这些工作。

- 缺页错误： 当软件试图访问已映射在虚拟地址空间中，但是**并未被加载在物理内存中的一个分页**时，由中央处理器的内存管理单元所发出的中断

## 阅读拓展

Q: RISV中用户程序执行系统调用的完整流程?

1. 用户代码执行`exec()`, 会执行对应的汇编代码，使得参数按顺序放在寄存器a0-a6中，对应的系统调用号会保存的a7中

2. 汇编代码最终执行`ecall`指令，发起一个用户空间trap，进入内核空间

3. 当发生用户空间的trap， RISC-V就会跳转到stvec中的地址，执行trampoline的uservec，保存用户进程的上下文保存到相关寄存器中，并且将内核的信息恢复出来保存到相关寄存器中

4. uservec在保存完毕后，会跳到内核空间的`usertrap()`中，根据保存在scause中的trap的类型来进行处理

5. 判断是一个系统调用，则执行`syscall()`函数

6. `syscall()`根据a7中保存的系统调用号，索引syscalls数组，找到对应的那个系统调用，通过函数指针执行相应的系统调用。

7. 最后，系统调用有一个返回值，在syscall中，内核将该返回值放置到trapframe中的a0

8. uservec中的的syscall执行完毕后，将会调用`usertrapret()`来完成trap的扫尾工作，需要将内核的信息重新保存到用户进程的内核结构,

9. 在用户空间下，会执行`userret`, 从寄存器中恢复用户进程的上下文， 并切换到用户空间

