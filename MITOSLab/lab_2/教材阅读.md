对应章节

- Chapter 2: Operating System Organization

## 知识点总结

- 宏内核设计：整个操作系统都在内核中(大多数Unix操作系统的方式)

- RISC-V是一个64位的CPU, 也是宏内核设计

- 三种隔离模式：

    1. 机器模式：在机器模式中运行的指令拥有最高特权级别。

        - CPU启动时首先被设置为机器模式，然后很快就跳转道到监管者模式

        - RISC-V提供了`mret`指令来从机器模式切换到监管者模式

    2. 监管者模式：可以执行特权指令的模式

    3. 用户模式：用户模式只能执行用户进程的指令

        - CPU应该提供一个特别的指令，可以令CPU从用户模式切换到监管者模式，同时通过一个由内核预先就设置好的进入点entry point，顺利地进入到内核当中

        - RISC-V提供了这个特别的指令，它叫做ecall;
            
            内核的进入点应该由内核自己来控制

    > - 内核空间：执行特权指令的内存
    > - 进程空间：执行用户指令的内存
    > - 内核：在内核空间下运行的软件/代码

- 指令操作的是虚拟地址，CPU访问用户进程的指令、数据、堆、栈等等，用的都是虚拟地址；而物理地址，是访问物理内存（例如DRAM）时使用的地址，CPU执行指令中的虚拟地址会被页表硬件自动转换为物理地址。

    - 每个进程一个页表

    - 当在用户空间执行用户进程时，xv6会将进程相应的p->pagetable装载到页表硬件（页表寄存器satp）

- RISC-V的指针是64位，64位虚拟地址中，只有低39位是正在被使用的。39位里的低38位实际表示着用户进程的虚拟地址，与kernel/riscv.h中的宏定义一致，**xv6中最大的虚拟地址MAXVA=2^38-1=0x3fffffffff**。

- 对每个进程而言有两个，分别是用户栈和内核栈。当进程在用户空间执行指令，使用的是用户栈，内核栈此时为空；而当进程因系统调用或中断而陷入内核时，内核代码此时切换到该进程的内核栈上执行，而它的用户栈仍然保持着原来的数据，只是现在暂时不使用

- RISC-V启动流程：

    1. 运行一个保存在ROM上的引导加载程序，加载`entry.S`中的`_entry`到0x80000000

    2. `_entry`将它自己的栈的栈顶地址放进sp寄存器.至此，内核真正拥有了一个栈，然后_entry就跳转到`start.c`的`start()`中。

        - 在`kernel/start.c`中为栈声明了空间。初始栈stack0，根据CPU的数量，为每个CPU都分配了一个4096B大小的栈
            ```C
            // entry.S needs one stack per CPU.
            __attribute__ ((aligned (16))) char stack0[4096 * NCPU];
            ```
    3. `start()`：CPU在机器模式下完成一些初始的配置工作，然后就准备切换到监管者模式，调用`main.c`(将main函数的地址写入mepc寄存器)

    3. `main.c`: 在main函数中完成对各设备和各子系统的初始化之后，调用userinit函数（kernel/proc.c）来创建第一个用户进程

    4.`userinit()`: 将一段汇编代码装载如虚拟地址空间，然后将该进程设置为RUNNABLE,就可以把调度器`main.c->scheduler()`调用. 这段汇编代码会调用`exec("/init")`

    5.新的用户程序init（/user/init.c）装载进来，并且完全替换掉用户进程旧的虚拟地址空间。从内核返回到用户空间时，我们已经身处init这个用户程序中了

        - 这个程序就是我们获得的控制台

## 阅读拓展