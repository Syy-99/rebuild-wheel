- 对应章节：
    - Chapter 1: Operating System Interfaces
## 知识点总结
- 内核提供的系统调用需要与底层的硬件设备打交道，这些指令是特权级别的（例如开关中断，读写寄存器的值等），在用户空间中不应该执行它们，而是要通过系统调用来陷入内核，再交由内核，替用户程序执行这些预先设置好的系统调用函数，完成更为底层的工作（例如与磁盘打交道）。

- `exec`函数可以用来替换进程内存映像，但是其他都将保持不变。`exec`只是用另一个新程序替换了当前进程的正文、数据、堆和栈段

- 通过`fork`或`dup`的系统调用，从一个相同的原始文件描述符派生出来的两个文件描述符，一定会共享同一个文件的偏移量。若不是这种情况，两个文件描述符不会共享偏移量，即使它们是通过open打开同一个文件获取的

- 管道pipe，是进程间通信的其中一种方式，本质是一个小的**内核缓冲区**。 匿名管道读写的特殊情况：

    - 如果所有指向管道**写端的文件描述符都关闭**，而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样**正常结束**
    v
    - 如果有指向管道**写端的文件描述符没关闭**，而持有管道**写端的进程也没有向管道中写数据**，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，**再次read会阻塞**，直到管道中有数据可读了才读取数据并返回。

    - 如果**所有指向管道读端的文件描述符都关闭**，这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。

    - 如果有指向管道**读端的文件描述符没关闭**，而持有**管道读端的进程也没有从管道中读数据**，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。

- cd被内置在shell中实现，而不是单独作为一个命令来实现相应的接口。这是因为cd应该改变进程的当前目录，而如果cd是当作一个命令来处理，那么shell就会创建一个子进程来执行cd，结果是只改变了子进程的当前目录，并没有改变父进程shell的当前目录

## 阅读扩展
Q1： 程序运行时如何判断是在用户态还是在内核态？

- 操作系统给不同的内存段限定了不同的访问模式，并把它记录到了段的描述符中；

    - 在访问内存的时候，CPU就会拿当前段寄存器中标示的权限和要访问的目标内存所在段段访问权限进行对比，符合要求才能访问，否则也会抛出异常


- 只有工作在Ring0模式下的内存区域，才能执行特权指令。对于进程来说，这块区域会映射到虚拟地址空间的高地址处，称为内核地址空间

    - 位于该空间中的代码称为内核代码(这部分代码是操作系统提供的)，CPU执行内核代码的模式称为内核态
        
    - CPU执行代码的过程，就是不断游走于用户态和内核态的过程。

- 用户态程序只能通过中断、异常、系统调用，将CPU切换到内核态，并转而执行内核地中空间处的代码

    - **x86机器通过寄存器cs上的低两位判断当前CPU的特权级**,因此系统调用实际上是因为某些代码实现需要用到特权指令，所以当用户需要特定功能时，必须通过特定的系统调用，先进入内核模式，再运行系统调用中的代码，然后返回结果

        > 具体细节这里不深入

[计算机怎么知道用户态和内核态？](https://www.zhihu.com/question/26188312)

Q2: 匿名管道 vs 有名管道

- 匿名管道：
    1. 只能用于父子或兄弟进程之间；
    
    2. 通过`pipe()`创建

- 有名管道：

    1. 可用于运行于同一系统中的任意两个进程间的通信

    2. 通过`makfifi()`创建

- 管道都是半双工的通信模式，只能一个进程读，另一个进程写，不能同时读写


